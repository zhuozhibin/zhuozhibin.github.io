{"meta":{"title":"ben~z blog","subtitle":"stay hungry stay foolish","description":null,"author":"卓智斌","url":"https://blog.zhuozhibin.com"},"pages":[{"title":"关于我","date":"2018-04-28T14:46:04.504Z","updated":"2018-04-28T14:46:04.504Z","comments":true,"path":"about/index.html","permalink":"https://blog.zhuozhibin.com/about/index.html","excerpt":"","text":"个人信息 广东工业大学-计算机学院-软件工程 zhuozhibin#foxmail.com 工作经历 2015.06 —— 至今 广州亮动信息科技有限公司，联合创始人、软件开发技术负责人 2013.01 —— 2015.05 北京启明星辰信息安全技术有限公司，终端安全事业部开发部，部门经理 2010.01 —— 2012.12 北京启明星辰信息安全技术有限公司，广州研发中心，软件工程师"},{"title":"Categories","date":"2018-01-06T13:55:26.388Z","updated":"2017-04-24T09:37:46.000Z","comments":true,"path":"categories/index.html","permalink":"https://blog.zhuozhibin.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-01-06T14:09:45.962Z","updated":"2018-01-06T14:09:45.947Z","comments":true,"path":"tags/index.html","permalink":"https://blog.zhuozhibin.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Gitlab环境搭建","slug":"install-gitlab","date":"2018-01-24T13:39:00.000Z","updated":"2018-04-27T06:46:14.379Z","comments":true,"path":"2018/01/24/install-gitlab/","link":"","permalink":"https://blog.zhuozhibin.com/2018/01/24/install-gitlab/","excerpt":"","text":"今天将原来使用的第三方git服务整体迁移到自己的搭建的gitlab服务器，后续所有版本开发管理，CI等都将在这里进行。对于Gitlab的搭建步骤，官方文档已经很详细明了，这里只是结合https的访问，做一次笔记的记录。 环境 ubuntu 安装并配置必要的依赖关系12sudo apt-get updatesudo apt-get install -y curl openssh-server ca-certificates 安装postfix用作发送邮件1sudo apt-get install -y postfix 这个步骤不是必须的，如果你想使用其他邮件发送方案，可以在安装完成后配置外部SMTP服务器 增加Gitlab包仓库和安装包12curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.deb.sh | sudo bashsudo apt-get install gitlab-ee Gitlab命令后续需要用到两个简单的Gitlab命令 重配置 gitlab-ctl reconfigure (这个会帮我们自动生成所需要的nginx配置) 重启服务 gitlab-ctl restart 配置Gitlab上面的步骤其实已经算把Gitlab搭出来了，下面配置只是根据自己使用需要，非必须的。 Gitlab的配置文件为 /etc/gitlab/gitlab.rb 里面的内容很容易看懂。 这里需要使用公司已有的域名进行访问，所以配置外部域名(如果要使用https，这里也需要修改正确) 1external_url \"http://gitlab.example.com\" 配置HTTPS证书现在HTTPS基本是标配，它需要可信证书，不然浏览器会显示不安全，而且显得非常low（&gt;_&lt;）。 可以到腾讯云申请免费域名证书，网上很多教程，这里不做详述。 将证书拷贝到服务器中(文件的访问权限需要正确配置 chmod 700) 12/etc/gitlab/ssl/*.crt/etc/gitlab/ssl/*.key 修改Gitlab配置文件1234external_url \"https://gitlab.example.com\"nginx['redirect_http_to_https_port'] = 80nginx['ssl_certificate'] = \"/etc/gitlab/ssl/*.crt\"nginx['ssl_certificate_key'] = \"/etc/gitlab/ssl/*.key\" 重配置和重启Gitlab即可12gitlab-ctl reconfiguregitlab-ctl restart 完成后 可能遇到的问题最低配置Gitlab建议最少2核4G的机器，否则就可能出现未知不能使用的问题，我使用的云服务器刚开始只分了1核1G给它，就出现不能使用的情况。 端口冲突如果不是使用干净的机器搭建，可能会出现端口冲突问题，Gitlab可以配置使用其它端口，具体参考官方文档即可。","categories":[{"name":"Note","slug":"Note","permalink":"https://blog.zhuozhibin.com/categories/Note/"}],"tags":[{"name":"note","slug":"note","permalink":"https://blog.zhuozhibin.com/tags/note/"},{"name":"ci","slug":"ci","permalink":"https://blog.zhuozhibin.com/tags/ci/"}]},{"title":"Node(CommonJS)模块机制","slug":"learning-node/node-module","date":"2018-01-10T03:36:00.000Z","updated":"2018-04-28T14:29:27.741Z","comments":true,"path":"2018/01/10/learning-node/node-module/","link":"","permalink":"https://blog.zhuozhibin.com/2018/01/10/learning-node/node-module/","excerpt":"","text":"1. 概述模块能被用来组织大型的项目以及分发Node项目。Node应用由模块组成，采用CommonJS规范。 2. 模块引用通过require方法引用模块到当前上下文。 1var http = require('http'); 3. 模块定义模块内定义的对象和方法默认都是模块私有的，必须导出才能给外部引用。导出需要用到module对象。 3.1 module对象Node内部提供一个Module构建函数。所有模块都是Module的实例。 12345function Module(id, parent) &#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; //... 每个模块内部都有一个module对象,代表当前模块，它有以下属性: 123456module.id //模块的识别符，通常是带有绝对路径的模块文件名。module.filename //模块的文件名，带有绝对路径。module.loaded //返回一个布尔值，表示模块是否已经完成加载。module.parent //返回一个对象，表示调用该模块的模块。module.children //返回一个数组，表示该模块要用到的其他模块。module.exports //表示模块对外输出的值。 3.2 module.exports属性module.exports属性表示当前模块对外导出的接口，require方法引用模块实际上就是读取该属性。 该属性由模块系统创建，初始化值为: 1&#123;&#125; 模块将需要导出的接口挂载在exports对象作为属性即可，或者可以直接改变其值。 12345678//module amodule.exports.add = function (a, b) &#123; return a + b;&#125;;//require avar a = require('./a');var sum = a.add(1, 2); 12345678910111213//moudule avar EventEmitter = require('events').EventEmitter;module.exports = new EventEmitter();setTimeout(function() &#123; module.exports.emit('ready');&#125;, 1000);//require avar a = require('./a');a.on('ready', function() &#123; console.log('module a is ready');&#125;); 3.3 exports变量为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的语句： 1var exports = module.exports; 当要导出接口时，可以向exports对象添加方法： 1234//module aexports.sub = function(a, b) &#123; return a - b;&#125; 由于exports默认是对module.exports的引用，若将exports变量直接指向一个新值，则会切断exports与module.exports的联系，导致使用exports不能导出接口： 1234567//module avar EventEmitter = require('events').EventEmitter;exports = new EventEmitter();//无效setTimeout(function() &#123; module.exports.emit('ready');&#125;, 1000); 123456//module aexports.hello = function() &#123; return 'hello';&#125;;module.exports = &#123;&#125;;//module.exports被赋予新值，导致exports无效 exports变量为了方便存在，但对于某些人却容易造成混乱，只使用module.exports则逻辑清晰许多。","categories":[{"name":"Node","slug":"Node","permalink":"https://blog.zhuozhibin.com/categories/Node/"},{"name":"Tutorial","slug":"Node/Tutorial","permalink":"https://blog.zhuozhibin.com/categories/Node/Tutorial/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://blog.zhuozhibin.com/tags/Node/"},{"name":"Javascript","slug":"Javascript","permalink":"https://blog.zhuozhibin.com/tags/Javascript/"}]},{"title":"C++11 auto类型推导","slug":"cpp/learning-cpp11/CPP11-auto类型推导","date":"2018-01-03T06:47:00.000Z","updated":"2018-04-29T03:33:10.125Z","comments":true,"path":"2018/01/03/cpp/learning-cpp11/CPP11-auto类型推导/","link":"","permalink":"https://blog.zhuozhibin.com/2018/01/03/cpp/learning-cpp11/CPP11-auto类型推导/","excerpt":"","text":"1. 概述自动类型推导基本是现代语言的一个必备特性。C++ 11引入了auto关键字(之前的C++也有auto，但用处不大)，实现了自动类型推导。在某些情况下方便了复杂类型的获取，简化编码，提高效率。但auto不能滥用，否则可能会给代码的维护性和可读性带来严重的影响。 建议只在确定只有带来好处，没有坏处的情况下使用auto 2. 基本使用1auto x = 5; //OK: x是int类型 1auto p = new auto(1); //OK: p是int*类型 auto可以用于new操作符，auto(1)推导出int(1)1const auto *v = &amp;x, u = 6; //OK: v是const int*类型，u是const int类型 &amp;x是int 类型，const auto 中的auto应该int类型，v被推导出const int * 类型，u被推导为const int类型。注意u必须有后面的”=6”，其初始化不能产生二义性(如=6.0)，否则编译错误。12static auto y = 0.0; //OK: y是double类型auto int r; //ERROR: auto不再表示存储类型指示符 1auto s; //ERROR: 无法推导出s的类型 由于auto是在编译期推导的，所以无法推出s类型，必须立即初始化。 3. 推导规则1234567891011int x = 0;auto * a = &amp;x; //a -&gt; int *, auto -&gt; intauto b = &amp;x; //b -&gt; int *, auto -&gt; int *auto &amp;c = x; //c -&gt; int &amp;, auto -&gt; intauto d = c; //d -&gt; int, auto-&gt; intconst auto e = x; //e -&gt; const int, auto -&gt; intauto f = e; //f -&gt; int, auto -&gt; intconst auto &amp; g = x; //g -&gt; const int &amp;, auto -&gt; intauto &amp; h = g; //h -&gt; const int &amp;, auto -&gt; const int 当不声明为指针或引用时，auto推导结果为，初始化表达式抛弃引用和cv限定符的类型。 当声明为指针或引用时，auto推导结果会保持初始化表达式的cv属性。 auto推导的结果与函数模板参数的自动推导类似。 4. 限制 auto不能用于函数参数 auto不能用于非静态成员变量 无法定义数组 123int arr[10] = &#123;0&#125;;auto a = arr; //OK, aa -&gt; int *auto b[10] = arr; //ERROR 无法推导出模板参数 12std::vector&lt;int&gt; vec;std::vector&lt;auto&gt; a = vec; //ERROR 5. 建议5.1 只在确定的情况下使用auto（不限以下几点） 简化迭代器代码 1234std::map&lt;double,double&gt; kv;std::map&lt;double,double&gt;::iterator iter = kv.begin();for(; iter != kv.end(); ++iter)...... 简化成 123std::map&lt;double,double&gt; kv;for(auto iter = kv.begin; iter != kv.end(); ++iter)...... 有一些迭代器类型会很长，更应该使用auto。","categories":[{"name":"C++","slug":"C","permalink":"https://blog.zhuozhibin.com/categories/C/"},{"name":"Learning C++11","slug":"C/Learning-C-11","permalink":"https://blog.zhuozhibin.com/categories/C/Learning-C-11/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.zhuozhibin.com/tags/C/"}]}]}